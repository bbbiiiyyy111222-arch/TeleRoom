const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const sqlite3 = require('sqlite3').verbose();
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');

// ========== –ö–†–ò–ü–¢–û–ì–†–ê–§–ò–ß–ï–°–ö–ê–Ø –ó–ê–©–ò–¢–ê ==========
const SECRET_KEY = crypto.randomBytes(32).toString('hex');
const ALGORITHM = 'aes-256-gcm';

function encrypt(text) {
    if (!text) return text;
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(ALGORITHM, Buffer.from(SECRET_KEY, 'hex'), iv);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    const authTag = cipher.getAuthTag();
    return JSON.stringify({ iv: iv.toString('hex'), encrypted, authTag: authTag.toString('hex') });
}

function decrypt(encryptedData) {
    if (!encryptedData || !encryptedData.startsWith('{')) return encryptedData;
    try {
        const { iv, encrypted, authTag } = JSON.parse(encryptedData);
        const decipher = crypto.createDecipheriv(ALGORITHM, Buffer.from(SECRET_KEY, 'hex'), Buffer.from(iv, 'hex'));
        decipher.setAuthTag(Buffer.from(authTag, 'hex'));
        let decrypted = decipher.update(encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    } catch {
        return encryptedData;
    }
}

const app = express();
const server = http.createServer(app);
const io = socketIo(server, { cors: { origin: '*', methods: ['GET', 'POST'] } });

// ========== –°–û–ó–î–ê–ù–ò–ï –ü–ê–ü–û–ö ==========
const folders = ['./uploads/voice', './uploads/photos', './uploads/files', './avatars', './database'];
folders.forEach(folder => {
    if (!fs.existsSync(folder)) fs.mkdirSync(folder, { recursive: true });
});

// ========== –ù–ê–°–¢–†–û–ô–ö–ê MULTER ==========
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        if (file.fieldname === 'voice') cb(null, './uploads/voice/');
        else if (file.fieldname === 'photo') cb(null, './uploads/photos/');
        else if (file.fieldname === 'file') cb(null, './uploads/files/');
        else if (file.fieldname === 'avatar') cb(null, './avatars/');
        else cb(null, './uploads/');
    },
    filename: (req, file, cb) => {
        const unique = Date.now() + '_' + file.originalname.replace(/[^a-zA-Z0-9.]/g, '_');
        cb(null, unique);
    }
});
const upload = multer({ storage });

// ========== –°–¢–ê–¢–ò–ß–ï–°–ö–ò–ï –§–ê–ô–õ–´ ==========
app.use(express.static(__dirname));
app.use('/uploads', express.static('uploads'));
app.use('/avatars', express.static('avatars'));
app.use(express.json({ limit: '100mb' }));
app.use(express.urlencoded({ extended: true, limit: '100mb' }));

// ========== –ë–ê–ó–ê –î–ê–ù–ù–´–• ==========
const db = new sqlite3.Database('./database/teleroom.db');

db.serialize(() => {
    db.run(`CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT UNIQUE NOT NULL,
        phone TEXT UNIQUE NOT NULL,
        avatar TEXT,
        bio TEXT DEFAULT '',
        online INTEGER DEFAULT 0,
        last_seen DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);
    db.run(`CREATE TABLE IF NOT EXISTS groups (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        description TEXT,
        avatar TEXT,
        created_by INTEGER NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (created_by) REFERENCES users(id)
    )`);
    db.run(`CREATE TABLE IF NOT EXISTS group_members (
        group_id INTEGER NOT NULL,
        user_id INTEGER NOT NULL,
        role TEXT DEFAULT 'member',
        joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (group_id, user_id)
    )`);
    db.run(`CREATE TABLE IF NOT EXISTS private_chats (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user1_id INTEGER NOT NULL,
        user2_id INTEGER NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user1_id, user2_id)
    )`);
    db.run(`CREATE TABLE IF NOT EXISTS messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        chat_type TEXT NOT NULL,
        chat_id INTEGER NOT NULL,
        user_id INTEGER NOT NULL,
        text TEXT,
        photo_url TEXT,
        voice_url TEXT,
        file_url TEXT,
        file_name TEXT,
        file_size INTEGER,
        duration TEXT,
        reply_to INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id)
    )`);
    console.log('‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –≥–æ—Ç–æ–≤–∞');
});

// ========== API –ü–†–û–í–ï–†–ö–ò –ò–ú–ï–ù–ò ==========
app.get('/api/check-username/:name', (req, res) => {
    db.get('SELECT id FROM users WHERE name = ?', [req.params.name], (err, user) => {
        res.json({ available: !user });
    });
});

// ========== API –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ô ==========
app.get('/api/users', (req, res) => {
    db.all('SELECT id, name, avatar, bio, online, last_seen FROM users ORDER BY name', (err, users) => res.json(users || []));
});
app.get('/api/users/:id', (req, res) => {
    db.get('SELECT id, name, avatar, bio, online, last_seen, created_at FROM users WHERE id = ?', [req.params.id], (err, user) => res.json(user || null));
});
app.post('/api/users/update-bio', (req, res) => {
    const { userId, bio } = req.body;
    db.run('UPDATE users SET bio = ? WHERE id = ?', [bio, userId], function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});

// ========== API –ü–†–û–§–ò–õ–Ø ==========
app.post('/api/user/update-name', (req, res) => {
    const { userId, newName } = req.body;
    db.get('SELECT id FROM users WHERE name = ? AND id != ?', [newName, userId], (err, existing) => {
        if (existing) return res.status(400).json({ error: '–ò–º—è –∑–∞–Ω—è—Ç–æ' });
        db.run('UPDATE users SET name = ? WHERE id = ?', [newName, userId], function(err) {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ success: true, name: newName });
            db.all('SELECT id, name, avatar, bio, online FROM users', (err, users) => io.emit('all_users', users || []));
        });
    });
});
app.post('/api/user/update-username', (req, res) => {
    const { userId, newUsername } = req.body;
    if (!newUsername || newUsername.length < 3) return res.status(400).json({ error: '–ú–∏–Ω–∏–º—É–º 3 —Å–∏–º–≤–æ–ª–∞' });
    db.get('SELECT id FROM users WHERE phone = ? AND id != ?', [newUsername, userId], (err, existing) => {
        if (existing) return res.status(400).json({ error: '–Æ–∑–µ—Ä–Ω–µ–π–º –∑–∞–Ω—è—Ç' });
        db.run('UPDATE users SET phone = ? WHERE id = ?', [newUsername, userId], function(err) {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ success: true, username: newUsername });
        });
    });
});
app.post('/api/user/upload-avatar', upload.single('avatar'), (req, res) => {
    if (!req.file) return res.status(400).json({ error: '–ù–µ—Ç —Ñ–∞–π–ª–∞' });
    const { userId } = req.body;
    const avatar = req.file.filename;
    db.run('UPDATE users SET avatar = ? WHERE id = ?', [avatar, userId], function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true, avatar });
        db.all('SELECT id, name, avatar, bio, online FROM users', (err, users) => io.emit('all_users', users || []));
    });
});
app.post('/api/user/remove-avatar', (req, res) => {
    const { userId } = req.body;
    db.run('UPDATE users SET avatar = NULL WHERE id = ?', [userId], function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
        db.all('SELECT id, name, avatar, bio, online FROM users', (err, users) => io.emit('all_users', users || []));
    });
});
app.get('/api/user/profile/:userId', (req, res) => {
    db.get('SELECT id, name, phone, avatar, bio, online, last_seen, created_at FROM users WHERE id = ?', [req.params.userId], (err, user) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(user || null);
    });
});

// ========== API –ì–†–£–ü–ü ==========
app.post('/api/groups', (req, res) => {
    const { name, description, userId } = req.body;
    db.run('INSERT INTO groups (name, description, created_by) VALUES (?, ?, ?)', [name, description || '', userId], function(err) {
        if (err) return res.status(500).json({ error: err.message });
        const groupId = this.lastID;
        db.run('INSERT INTO group_members (group_id, user_id, role) VALUES (?, ?, ?)', [groupId, userId, 'admin']);
        res.json({ id: groupId, name, description });
    });
});
app.get('/api/groups/:userId', (req, res) => {
    db.all(`SELECT g.*, COUNT(DISTINCT gm.user_id) as members_count,
            (SELECT text FROM messages WHERE chat_type='group' AND chat_id=g.id ORDER BY created_at DESC LIMIT 1) as last_message,
            (SELECT created_at FROM messages WHERE chat_type='group' AND chat_id=g.id ORDER BY created_at DESC LIMIT 1) as last_time
            FROM groups g JOIN group_members gm ON g.id=gm.group_id WHERE gm.user_id=? GROUP BY g.id ORDER BY g.created_at DESC`,
        [req.params.userId], (err, groups) => res.json(groups || []));
});
app.get('/api/groups/:groupId/members', (req, res) => {
    db.all(`SELECT u.id, u.name, u.avatar, u.online, u.last_seen, gm.role, gm.joined_at
            FROM group_members gm JOIN users u ON gm.user_id=u.id WHERE gm.group_id=? ORDER BY gm.joined_at`,
        [req.params.groupId], (err, members) => res.json(members || []));
});
app.post('/api/groups/add_member', (req, res) => {
    const { group_id, user_id } = req.body;
    db.run('INSERT OR IGNORE INTO group_members (group_id, user_id) VALUES (?, ?)', [group_id, user_id], function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});
app.post('/api/groups/update-name', (req, res) => {
    const { groupId, userId, newName } = req.body;
    db.get('SELECT role FROM group_members WHERE group_id=? AND user_id=?', [groupId, userId], (err, member) => {
        if (!member || member.role !== 'admin') return res.status(403).json({ error: '–ù–µ—Ç –ø—Ä–∞–≤' });
        db.run('UPDATE groups SET name=? WHERE id=?', [newName, groupId], function(err) {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ success: true, name: newName });
        });
    });
});
app.post('/api/groups/update-description', (req, res) => {
    const { groupId, userId, newDescription } = req.body;
    db.get('SELECT role FROM group_members WHERE group_id=? AND user_id=?', [groupId, userId], (err, member) => {
        if (!member || member.role !== 'admin') return res.status(403).json({ error: '–ù–µ—Ç –ø—Ä–∞–≤' });
        db.run('UPDATE groups SET description=? WHERE id=?', [newDescription, groupId], function(err) {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ success: true, description: newDescription });
        });
    });
});
app.get('/api/messages/group/:groupId', (req, res) => {
    db.all(`SELECT m.*, u.name as user_name, u.avatar as user_avatar FROM messages m
            JOIN users u ON m.user_id=u.id WHERE m.chat_type='group' AND m.chat_id=? ORDER BY m.created_at ASC LIMIT 200`,
        [req.params.groupId], (err, messages) => {
            const decrypted = messages.map(m => ({ ...m, text: decrypt(m.text) }));
            res.json(decrypted || []);
        });
});

// ========== API –õ–ò–ß–ù–´–• –ß–ê–¢–û–í ==========
app.post('/api/private_chat', (req, res) => {
    const { user1_id, user2_id } = req.body;
    const min = Math.min(user1_id, user2_id), max = Math.max(user1_id, user2_id);
    db.run('INSERT OR IGNORE INTO private_chats (user1_id, user2_id) VALUES (?, ?)', [min, max], function(err) {
        if (err) return res.status(500).json({ error: err.message });
        db.get('SELECT id FROM private_chats WHERE user1_id=? AND user2_id=?', [min, max], (err, chat) => {
            if (!chat) return res.status(404).json({ error: '–ß–∞—Ç –Ω–µ —Å–æ–∑–¥–∞–Ω' });
            res.json({ chat_id: chat.id });
        });
    });
});
app.get('/api/private_chats/:userId', (req, res) => {
    const uid = parseInt(req.params.userId);
    db.all(`SELECT pc.id,
            CASE WHEN pc.user1_id=? THEN pc.user2_id ELSE pc.user1_id END as other_user_id,
            u.name as other_user_name, u.avatar as other_user_avatar, u.online, u.last_seen,
            (SELECT text FROM messages WHERE chat_type='private' AND chat_id=pc.id ORDER BY created_at DESC LIMIT 1) as last_message,
            (SELECT created_at FROM messages WHERE chat_type='private' AND chat_id=pc.id ORDER BY created_at DESC LIMIT 1) as last_time
            FROM private_chats pc JOIN users u ON (CASE WHEN pc.user1_id=? THEN pc.user2_id ELSE pc.user1_id END)=u.id
            WHERE pc.user1_id=? OR pc.user2_id=? ORDER BY last_time DESC`,
        [uid, uid, uid, uid], (err, chats) => res.json(chats || []));
});
app.get('/api/messages/private/:chatId', (req, res) => {
    db.all(`SELECT m.*, u.name as user_name, u.avatar as user_avatar FROM messages m
            JOIN users u ON m.user_id=u.id WHERE m.chat_type='private' AND m.chat_id=? ORDER BY m.created_at ASC LIMIT 200`,
        [req.params.chatId], (err, messages) => {
            const decrypted = messages.map(m => ({ ...m, text: decrypt(m.text) }));
            res.json(decrypted || []);
        });
});

// ========== –ó–ê–ì–†–£–ó–ö–ê –§–ê–ô–õ–û–í ==========
app.post('/api/upload/voice', upload.single('voice'), (req, res) => {
    if (!req.file) return res.status(400).json({ error: '–ù–µ—Ç —Ñ–∞–π–ª–∞' });
    const { chat_type, chat_id, user_id, duration } = req.body;
    db.run('INSERT INTO messages (chat_type, chat_id, user_id, voice_url, duration) VALUES (?,?,?,?,?)',
        [chat_type, chat_id, user_id, req.file.filename, duration || '0:05'], function(err) {
            if (err) return res.status(500).json({ error: err.message });
            db.get(`SELECT m.*, u.name as user_name, u.avatar as user_avatar FROM messages m JOIN users u ON m.user_id=u.id WHERE m.id=?`,
                [this.lastID], (err, msg) => {
                    if (!msg) return res.status(404).json({ error: '–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' });
                    io.to(chat_type === 'group' ? `group_${chat_id}` : `private_${chat_id}`).emit('new_message', msg);
                    res.json(msg);
                });
        });
});
app.post('/api/upload/photo', upload.single('photo'), (req, res) => {
    if (!req.file) return res.status(400).json({ error: '–ù–µ—Ç —Ñ–∞–π–ª–∞' });
    const { chat_type, chat_id, user_id } = req.body;
    db.run('INSERT INTO messages (chat_type, chat_id, user_id, photo_url, text) VALUES (?,?,?,?,?)',
        [chat_type, chat_id, user_id, req.file.filename, encrypt('üì∑ –§–æ—Ç–æ')], function(err) {
            if (err) return res.status(500).json({ error: err.message });
            db.get(`SELECT m.*, u.name as user_name, u.avatar as user_avatar FROM messages m JOIN users u ON m.user_id=u.id WHERE m.id=?`,
                [this.lastID], (err, msg) => {
                    if (!msg) return res.status(404).json({ error: '–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' });
                    msg.text = decrypt(msg.text);
                    io.to(chat_type === 'group' ? `group_${chat_id}` : `private_${chat_id}`).emit('new_message', msg);
                    res.json(msg);
                });
        });
});
app.post('/api/upload/file', upload.single('file'), (req, res) => {
    if (!req.file) return res.status(400).json({ error: '–ù–µ—Ç —Ñ–∞–π–ª–∞' });
    const { chat_type, chat_id, user_id } = req.body;
    db.run('INSERT INTO messages (chat_type, chat_id, user_id, file_url, file_name, file_size, text) VALUES (?,?,?,?,?,?,?)',
        [chat_type, chat_id, user_id, req.file.filename, req.file.originalname, req.file.size, encrypt('üìé –§–∞–π–ª')], function(err) {
            if (err) return res.status(500).json({ error: err.message });
            db.get(`SELECT m.*, u.name as user_name, u.avatar as user_avatar FROM messages m JOIN users u ON m.user_id=u.id WHERE m.id=?`,
                [this.lastID], (err, msg) => {
                    if (!msg) return res.status(404).json({ error: '–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' });
                    msg.text = decrypt(msg.text);
                    io.to(chat_type === 'group' ? `group_${chat_id}` : `private_${chat_id}`).emit('new_message', msg);
                    res.json(msg);
                });
        });
});

// ========== WEB SOCKET ==========
io.on('connection', (socket) => {
    console.log('üë§ –ü–æ–¥–∫–ª—é—á–∏–ª—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å');

    socket.on('register', (userData) => {
        const { name, phone } = userData;
        db.get('SELECT * FROM users WHERE phone = ?', [phone], (err, existingUser) => {
            if (existingUser) {
                socket.userId = existingUser.id;
                socket.userName = existingUser.name;
                db.run('UPDATE users SET online = 1, last_seen = CURRENT_TIMESTAMP WHERE id = ?', [existingUser.id]);
                socket.emit('registered', existingUser);
                // ... –æ—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö (—Å–æ–∫—Ä–∞—â–µ–Ω–æ, –Ω–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
                db.all(`SELECT g.*, COUNT(DISTINCT gm.user_id) as members_count FROM groups g
                        JOIN group_members gm ON g.id=gm.group_id WHERE gm.user_id=? GROUP BY g.id`,
                    [existingUser.id], (e, g) => socket.emit('user_groups', g || []));
                db.all(`SELECT pc.id, CASE WHEN pc.user1_id=? THEN pc.user2_id ELSE pc.user1_id END as other_user_id,
                        u.name as other_user_name, u.avatar as other_user_avatar, u.online
                        FROM private_chats pc JOIN users u ON (CASE WHEN pc.user1_id=? THEN pc.user2_id ELSE pc.user1_id END)=u.id
                        WHERE pc.user1_id=? OR pc.user2_id=?`, [existingUser.id, existingUser.id, existingUser.id, existingUser.id],
                    (e, p) => socket.emit('user_private_chats', p || []));
                db.all('SELECT id, name, avatar, bio, online FROM users', (e, u) => socket.emit('all_users', u || []));
                socket.broadcast.emit('user_online', existingUser.id);
                return;
            }
            db.get('SELECT * FROM users WHERE name = ?', [name], (err, existingName) => {
                if (existingName) {
                    socket.emit('register_error', '–≠—Ç–æ –∏–º—è —É–∂–µ –∑–∞–Ω—è—Ç–æ!');
                    return;
                }
                db.run('INSERT INTO users (name, phone) VALUES (?, ?)', [name, phone], function(err) {
                    if (err) return socket.emit('register_error', '–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏');
                    db.get('SELECT * FROM users WHERE id = ?', [this.lastID], (err, newUser) => {
                        if (!newUser) return socket.emit('register_error', '–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è');
                        socket.userId = newUser.id;
                        socket.userName = newUser.name;
                        db.run('UPDATE users SET online = 1 WHERE id = ?', [newUser.id]);
                        socket.emit('registered', newUser);
                        db.all('SELECT id, name, avatar, bio, online FROM users', (e, u) => socket.emit('all_users', u || []));
                        socket.broadcast.emit('user_online', newUser.id);
                    });
                });
            });
        });
    });

    socket.on('join_group', (gid) => { socket.join(`group_${gid}`); console.log(`üë• ${socket.userName} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –≥—Ä—É–ø–ø–µ ${gid}`); });
    socket.on('join_private_chat', (cid) => { socket.join(`private_${cid}`); console.log(`üí¨ ${socket.userName} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –ª–∏—á–Ω–æ–º—É —á–∞—Ç—É ${cid}`); });
    socket.on('send_message', (data) => {
        const { chat_type, chat_id, user_id, text } = data;
        const encryptedText = encrypt(text);
        db.run('INSERT INTO messages (chat_type, chat_id, user_id, text) VALUES (?,?,?,?)',
            [chat_type, chat_id, user_id, encryptedText], function(err) {
                if (err) return console.error(err);
                db.get(`SELECT m.*, u.name as user_name, u.avatar as user_avatar FROM messages m JOIN users u ON m.user_id=u.id WHERE m.id=?`,
                    [this.lastID], (err, msg) => {
                        if (msg) {
                            msg.text = decrypt(msg.text);
                            io.to(chat_type === 'group' ? `group_${chat_id}` : `private_${chat_id}`).emit('new_message', msg);
                        }
                    });
            });
    });
    socket.on('typing', (d) => {
        const room = d.chat_type === 'group' ? `group_${d.chat_id}` : `private_${d.chat_id}`;
        socket.to(room).emit('user_typing', { user_id: d.user_id, user_name: d.user_name });
    });
    socket.on('update_bio', ({ userId, bio }) => {
        db.run('UPDATE users SET bio = ? WHERE id = ?', [bio, userId], function(err) {
            if (!err) db.all('SELECT id, name, avatar, bio, online FROM users', (e, u) => io.emit('all_users', u || []));
        });
    });
    socket.on('disconnect', () => {
        if (socket.userId) {
            db.run('UPDATE users SET online = 0, last_seen = CURRENT_TIMESTAMP WHERE id = ?', [socket.userId]);
            socket.broadcast.emit('user_offline', socket.userId);
            console.log(`üëã ${socket.userName} –æ—Ç–∫–ª—é—á–∏–ª—Å—è`);
        }
    });
});

// ========== –ì–õ–ê–í–ù–ê–Ø ==========
app.get('/', (req, res) => res.sendFile(__dirname + '/index.html'));

// ========== –ó–ê–ü–£–°–ö ==========
const PORT = process.env.PORT || 3000;
server.listen(PORT, '0.0.0.0', () => {
    console.log('\n' + '='.repeat(60));
    console.log('   üöÄ TeleRoom PRO - –≠–õ–ò–¢–ù–û–ï –®–ò–§–†–û–í–ê–ù–ò–ï');
    console.log('='.repeat(60));
    console.log(`   üì± –ü–æ—Ä—Ç: ${PORT}`);
    console.log('   üîê AES-256-GCM –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω');
    console.log('   ‚úÖ –í—Ö–æ–¥ - —Ä–∞–±–æ—Ç–∞–µ—Ç');
    console.log('   ‚úÖ –ü—Ä–æ—Ñ–∏–ª—å - —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —É –∞–≤–∞—Ç–∞—Ä–∫–∏');
    console.log('   ‚úÖ –ê–≤–∞—Ç–∞—Ä–∫–∏, –∏–º—è, —é–∑–µ—Ä–Ω–µ–π–º, –±–∏–æ');
    console.log('   ‚úÖ –ì—Ä—É–ø–ø—ã, –ª–∏—á–Ω—ã–µ —á–∞—Ç—ã, —Å–æ–æ–±—â–µ–Ω–∏—è');
    console.log('='.repeat(60) + '\n');
});
